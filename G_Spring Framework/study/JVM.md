# JVM 가비지 컬렉터 (GC) - Mark & Sweep 알고리즘과 클래스 로더 시스템

## 1. Mark & Sweep 알고리즘

### 🔍 개요
Mark & Sweep은 가장 기본적이고 널리 사용되는 **GC(Garbage Collection)** 알고리즘 중 하나입니다. 이 알고리즘은 JVM이 불필요한 객체를 메모리에서 자동으로 제거하기 위해 사용합니다.

### ⚙️ 작동 원리
Mark & Sweep 알고리즘은 크게 두 단계로 구성됩니다:

#### 1. Mark 단계 (표시 단계)
- **루트 객체(GC Root)**에서 시작하여, **도달 가능한 객체들을 탐색**합니다.
- 도달 가능한 객체는 살아있는 객체로 간주되어 **표시(Mark)**됩니다.
- GC Root에는 다음과 같은 것이 포함됩니다:
    - 스레드 스택에 있는 로컬 변수
    - 정적 변수(static field)
    - 메서드 영역의 클래스 참조
    - JNI에서 참조 중인 객체

#### 2. Sweep 단계 (제거 단계)
- Heap 전체를 스캔하면서 **표시되지 않은 객체**를 찾아 **메모리에서 제거**합니다.
- 표시된 객체는 그대로 남겨둡니다.

### 📌 특징
- **Stop-the-world** 방식: Mark와 Sweep 단계 모두 애플리케이션 실행을 일시 정지함
- **프래그먼트 발생 가능**: 제거 후 메모리에 빈 공간이 흩어짐 (이는 Compaction 단계로 해결할 수 있음)

### ✅ 장점
- 구조가 단순하고 구현이 쉽다.

### ❌ 단점
- 애플리케이션 정지 시간(STW)이 길다.
- 메모리 단편화(fragmentation)가 발생한다.

### 💡 스프링과의 연관성
- 스프링은 객체를 싱글톤 빈으로 관리하거나 DI로 생성하여 JVM Heap에 보관합니다.
- GC가 동작할 때 **사용되지 않는 빈 객체나 미처 관리하지 못한 객체가 수집**됩니다.
- **ApplicationContext** 자체가 많은 참조를 보유하므로, 제대로 close하지 않으면 GC 되지 않고 **메모리 누수 발생** 가능
- GC 튜닝은 스프링 서버의 **성능, 응답속도, 안정성**에 직접적인 영향을 줍니다.

---

## 2. 클래스 로더 시스템 (Class Loader System)

### 📖 개요
클래스 로더(ClassLoader)는 자바 클래스 파일(.class)을 JVM의 메모리에 로딩하는 역할을 합니다. 스프링, 서블릿 컨테이너, WAS 등 모든 자바 애플리케이션은 **클래스 로더에 의해 클래스가 메모리에 탑재되고 실행**됩니다.

### 🧱 주요 역할
- 클래스 파일을 읽어들여 메모리에 로딩
- JVM이 사용하는 런타임 클래스 구조를 생성
- 네임스페이스를 구분하여 충돌 방지

### 🧩 클래스 로더의 계층 구조
1. **Bootstrap Class Loader**
    - 가장 상위의 로더, **JDK 내부 핵심 클래스(java.lang, java.util 등)**를 로드
    - C/C++로 구현되어 있고 Java 코드에서는 `null`로 표현됨

2. **Platform Class Loader (Java 9 이후)**
    - 플랫폼 클래스(java.sql, javax 등) 로드

3. **System Class Loader (Application Class Loader)**
    - classpath에 포함된 클래스들 로드
    - 우리가 작성한 애플리케이션 코드 대부분은 여기서 로드됨

4. **Custom Class Loader**
    - 필요에 따라 사용자가 직접 만든 클래스 로더

### 🪜 클래스 로더 위임 모델 (Delegation Model)
- 클래스 로더는 클래스를 로드할 때, **먼저 부모 클래스 로더에게 위임**합니다.
- 부모가 로드를 못 했을 때만 **자기 자신이 로드 시도**
- 이로 인해 **클래스 중복 로딩 방지**와 **보안 강화** 가능

### 👀 스프링과의 연관성
- 스프링은 **리플렉션**, **프록시**, **AOP**, **빈 스코프 처리** 등에서 클래스 로더를 적극 활용함
- **스프링 부트**의 경우 `org.springframework.boot.loader.LaunchedURLClassLoader`처럼 자체 클래스 로더를 통해 fat jar를 로드함
- 웹 서버(WAS) 환경에서는 스프링 컨텍스트와 톰캣의 클래스 로더가 다르기 때문에, **클래스 충돌이나 NoClassDefFoundError** 발생 가능
- **클래스 리로딩**(예: Spring Devtools)은 Custom ClassLoader로 구현되어 있음

### 📌 실전에서 주의할 점
- 서블릿 컨테이너에 스프링을 올릴 경우, WEB-INF/lib, WEB-INF/classes, 시스템 클래스 경로 등이 **각기 다른 클래스 로더**로 분리됨
- 스프링 빈이 서로 다른 클래스 로더에 존재하면 DI가 실패할 수 있음 → **동일 클래스 로더에 로드되도록 설정 필요**

---

## 🔚 마무리
> Mark & Sweep 알고리즘은 JVM의 메모리 관리를 담당하고,
> 클래스 로더 시스템은 자바 클래스 구조의 기반을 이룹니다.

스프링 프레임워크는 이 두 요소를 기반으로 복잡한 기능(AOP, DI, 프로파일링, 리플렉션 등)을 구현하므로,
이 두 개념을 정확히 이해하면 **스프링의 근본 원리와 성능 최적화 방향**을 깊이 있게 파악할 수 있습니다.
