# ğŸ“˜ ê·¸ë˜í”„ì™€ íƒìƒ‰ ì•Œê³ ë¦¬ì¦˜ ì •ë¦¬

![](https://beam307.github.io/assets/images/algorithm/bfs_dfs.gif)

---

## ğŸ”¹ ê·¸ë˜í”„ ê¸°ë³¸ ê°œë…

- **ê·¸ë˜í”„(Graph)**: ì •ì (Vertex)ê³¼ ê°„ì„ (Edge)ìœ¼ë¡œ êµ¬ì„±ëœ ìë£Œêµ¬ì¡°
- **ì •ì (Vertex, Node)**: ë°ì´í„°ë¥¼ ë‹´ê³  ìˆëŠ” ë‹¨ìœ„
- **ê°„ì„ (Edge)**: ì •ì  ê°„ì˜ ê´€ê³„ (ë°©í–¥ì´ ìˆì„ ìˆ˜ë„, ì—†ì„ ìˆ˜ë„ ìˆìŒ)

### ê·¸ë˜í”„ì˜ ì¢…ë¥˜
![](https://laboputer.github.io/assets/img/algorithm/ds/06_graph2.PNG)

- **ë¬´ë°©í–¥ ê·¸ë˜í”„(Undirected Graph)**: ê°„ì„ ì´ ì–‘ë°©í–¥
- **ë°©í–¥ ê·¸ë˜í”„(Directed Graph)**: ê°„ì„ ì— ë°©í–¥ì´ ìˆìŒ
- **ê°€ì¤‘ì¹˜ ê·¸ë˜í”„(Weighted Graph)**: ê°„ì„ ì— ë¹„ìš© ë˜ëŠ” ê±°ë¦¬ ë“±ì´ í• ë‹¹ë¨
- **ì—°ê²° ê·¸ë˜í”„(Connected Graph)**: ëª¨ë“  ì •ì ì´ ì—°ê²°ë˜ì–´ ìˆëŠ” ê·¸ë˜í”„
- **ì™„ì „ ê·¸ë˜í”„(Complete Graph)**: ëª¨ë“  ì •ì ì´ ì„œë¡œ ì—°ê²°ëœ ê·¸ë˜í”„

---

## ğŸ”¹ 1. ë‹¤ìµìŠ¤íŠ¸ë¼ ì•Œê³ ë¦¬ì¦˜ (Dijkstra)

- **ìš©ë„**: í•œ ì •ì ì—ì„œ ë‹¤ë¥¸ ëª¨ë“  ì •ì ê¹Œì§€ì˜ ìµœë‹¨ ê²½ë¡œ
- **ì œí•œ**: ê°€ì¤‘ì¹˜ê°€ ìŒìˆ˜ì´ë©´ ì‚¬ìš© ë¶ˆê°€

### ğŸ’¡ í•µì‹¬ ì›ë¦¬
1. ì‹œì‘ ë…¸ë“œì˜ ê±°ë¦¬ë¥¼ 0, ë‚˜ë¨¸ì§€ëŠ” ë¬´í•œìœ¼ë¡œ ì„¤ì •
2. ê°€ì¥ ê°€ê¹Œìš´ ë…¸ë“œë¥¼ ì„ íƒí•˜ì—¬ ì´ì›ƒ ë…¸ë“œì˜ ê±°ë¦¬ë¥¼ ê°±ì‹ 
3. ë°©ë¬¸í•˜ì§€ ì•Šì€ ë…¸ë“œ ì¤‘ ê°€ì¥ ì§§ì€ ê±°ë¦¬ì˜ ë…¸ë“œë¥¼ ì„ íƒí•˜ê³  ë°˜ë³µ

![](https://blog.kakaocdn.net/dn/czTlxm/btsnnObj6uY/g5xeKjcaD3VZmm2m5VanZK/img.gif)

### âœ… ìë°” ì˜ˆì œ ì½”ë“œ
```java
import java.util.*;

class Dijkstra {
    static class Node implements Comparable<Node> {
        int index, cost;
        Node(int index, int cost) {
            this.index = index;
            this.cost = cost;
        }
        public int compareTo(Node other) {
            return this.cost - other.cost;
        }
    }

    static final int INF = Integer.MAX_VALUE;

    public static void dijkstra(List<List<Node>> graph, int start, int[] dist) {
        PriorityQueue<Node> pq = new PriorityQueue<>();
        pq.offer(new Node(start, 0));
        dist[start] = 0;

        while (!pq.isEmpty()) {
            Node cur = pq.poll();

            if (dist[cur.index] < cur.cost) continue;

            for (Node neighbor : graph.get(cur.index)) {
                int newCost = dist[cur.index] + neighbor.cost;
                if (newCost < dist[neighbor.index]) {
                    dist[neighbor.index] = newCost;
                    pq.offer(new Node(neighbor.index, newCost));
                }
            }
        }
    }
}
```

---

## ğŸ”¹ 2. í”Œë¡œì´ë“œ ì›Œì…œ ì•Œê³ ë¦¬ì¦˜ (Floyd-Warshall)

- **ìš©ë„**: ëª¨ë“  ë…¸ë“œ ê°„ ìµœë‹¨ ê±°ë¦¬ ê³„ì‚°
- **íŠ¹ì§•**: ìŒì˜ ê°€ì¤‘ì¹˜ í—ˆìš© (ë‹¨, ìŒì˜ ì‚¬ì´í´ì€ ë¶ˆê°€)

### ğŸ’¡ í•µì‹¬ ì›ë¦¬
- `dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])`
- ì¤‘ê°„ ë…¸ë“œ `k`ë¥¼ ê±°ì¹˜ëŠ” ê²½ìš°ë¥¼ ë°˜ë³µí•˜ì—¬ ìµœë‹¨ê±°ë¦¬ ê°±ì‹ 

![](https://blog.kakaocdn.net/dn/uC9In/btrX4iVZxhp/OSubywGuVPhCaZZMPJ0Ypk/img.gif)

### âœ… ìë°” ì˜ˆì œ ì½”ë“œ
```java
class FloydWarshall {
    static final int INF = 1_000_000_000;

    public static void floyd(int[][] dist, int n) {
        for (int k = 0; k < n; k++) {
            for (int i = 0; i < n; i++) {
                for (int j = 0; j < n; j++) {
                    if (dist[i][k] + dist[k][j] < dist[i][j]) {
                        dist[i][j] = dist[i][k] + dist[k][j];
                    }
                }
            }
        }
    }
}
```

---

## ğŸ”¹ 3. ë„ˆë¹„ ìš°ì„  íƒìƒ‰ (BFS)

- **íŠ¹ì§•**: ê°€ê¹Œìš´ ë…¸ë“œë¶€í„° ìš°ì„  íƒìƒ‰ (í í™œìš©)
- **ìš©ë„**: ìµœë‹¨ê±°ë¦¬, ë ˆë²¨ íƒìƒ‰ ë“±

### âœ… ìë°” ì˜ˆì œ ì½”ë“œ
```java
import java.util.*;

class BFS {
    public static void bfs(List<List<Integer>> graph, int start, boolean[] visited) {
        Queue<Integer> queue = new LinkedList<>();
        queue.offer(start);
        visited[start] = true;

        while (!queue.isEmpty()) {
            int cur = queue.poll();
            System.out.print(cur + " ");
            for (int next : graph.get(cur)) {
                if (!visited[next]) {
                    queue.offer(next);
                    visited[next] = true;
                }
            }
        }
    }
}
```

---

## ğŸ”¹ 4. ê¹Šì´ ìš°ì„  íƒìƒ‰ (DFS)

- **íŠ¹ì§•**: ìµœëŒ€í•œ ê¹Šê²Œ íƒìƒ‰ (ìŠ¤íƒ/ì¬ê·€ í™œìš©)
- **ìš©ë„**: ë°±íŠ¸ë˜í‚¹, ìˆœì—´/ì¡°í•© íƒìƒ‰ ë“±

### âœ… ìë°” ì˜ˆì œ ì½”ë“œ
```java
import java.util.*;

class DFS {
    public static void dfs(List<List<Integer>> graph, int cur, boolean[] visited) {
        visited[cur] = true;
        System.out.print(cur + " ");

        for (int next : graph.get(cur)) {
            if (!visited[next]) {
                dfs(graph, next, visited);
            }
        }
    }
}
```

---

## ğŸ”¹ 5. ì´ì§„ íƒìƒ‰ (Binary Search)

- **íŠ¹ì§•**: ì •ë ¬ëœ ë°°ì—´ì— ëŒ€í•´ O(log n) ì‹œê°„ìœ¼ë¡œ íƒìƒ‰
- **ì¡°ê±´**: ë°°ì—´ì´ ì •ë ¬ë˜ì–´ ìˆì–´ì•¼ í•¨

### âœ… ìë°” ì˜ˆì œ ì½”ë“œ
```java
class BinarySearch {
    public static int binarySearch(int[] arr, int target) {
        int left = 0, right = arr.length - 1;
        while (left <= right) {
            int mid = (left + right) / 2;
            if (arr[mid] == target) return mid;
            if (arr[mid] < target) left = mid + 1;
            else right = mid - 1;
        }
        return -1;
    }
}
```

---

## ğŸ“Œ ë§ˆë¬´ë¦¬ ìš”ì•½
| ì•Œê³ ë¦¬ì¦˜         | ëª©ì                      | ì‹œê°„ ë³µì¡ë„   | íŠ¹ì§•                                |
|------------------|--------------------------|----------------|-------------------------------------|
| ë‹¤ìµìŠ¤íŠ¸ë¼       | í•œ ì •ì  -> ëª¨ë“  ì •ì      | O(E log V)     | ìŒì˜ ê°€ì¤‘ì¹˜ X, ìš°ì„ ìˆœìœ„ í ì‚¬ìš©     |
| í”Œë¡œì´ë“œ ì›Œì…œ    | ëª¨ë“  ì •ì  -> ëª¨ë“  ì •ì    | O(VÂ³)          | ìŒì˜ ê°€ì¤‘ì¹˜ O, ìŒì˜ ì‚¬ì´í´ X        |
| BFS              | ê°€ê¹Œìš´ ë…¸ë“œ ìš°ì„  íƒìƒ‰    | O(V + E)       | ìµœë‹¨ ê±°ë¦¬ íƒìƒ‰ì— ìœ ë¦¬, í ì‚¬ìš©       |
| DFS              | ê¹Šì€ ë…¸ë“œ ìš°ì„  íƒìƒ‰      | O(V + E)       | ë°±íŠ¸ë˜í‚¹, ì¡°í•© íƒìƒ‰, ì¬ê·€ í™œìš©       |
| ì´ì§„ íƒìƒ‰        | ì •ë ¬ëœ ë°°ì—´ì—ì„œ íƒìƒ‰     | O(log n)       | ì •ë ¬ í•„ìš”, íƒìƒ‰ ì†ë„ ë¹ ë¦„            |

